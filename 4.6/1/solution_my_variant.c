/*
 * Некоторая утилита генерирует  довольно  большой  вывод,  а  вам  требуется  *
 * всего-лишь посчитать количество символов '0'  в  этом  выводе.   Утилита  при
 * запуске принимает 1 параметр.  Вам требуется разработать  программу,  которая
 * вызывает указанную утилиту, с заданным параметром и	подсчитывает  количество
 * символов '0' в ее выводе.  Ваша программа принимает на вход	2  параметра  --
 * имя утилиты, в текущем каталоге и ее параметр.  Ваша программа  должна  после
 * подсчета вывести найденное число  '0'  в  отдельной	строке,  заканчивающейся
 * символом конца  строки.   
 *
 * Пример  вызова  
 * ./solution  someprog  param  234222
 *
 * Представление решения
 *
 * Решение предоставляется в виде двух  файлов  solution.c
 * и Makefile, в последнем предполагается цель по умолчанию, которая приводит  к
 * сборке Вашего приложения.  Бинарный файл  вашего  решения  должен  иметь  имя
 * solution. 
 *
 * Вывод
 *
 * Программа выводит в стандартный поток вывода число  (в  *  отдельной  строке)
 */

/* --- ПРИМЕЧАНИЕ --- 
 * Когда  заливал  этот  код  в  систему  тестирования  выдавало  эту	 ошибку:
 * Solution  was  killed  due	to  timeout  Проблема  была  в	том  что  я  всё
 * усложнил.  Предположил что нужно делать fork() и  исполнять	команду  в  теле
 * потомка, а родитель будет читать поток и считать нули.   Но	оказалось  нужно
 * было просто воспользоваться функцией popen().  Короче  задача  намного  проще
 * чем может показаться.
 */

#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int  count_zero_in_str(int fd);

int main(int argc, char *argv[])
{
	pid_t cpid;
	int   fd[2];
	int   sum_zero = 0;
	char  *v[3];
	char  c;

	v[0] = argv[1];
	v[1] = argv[2];
	v[2] = (char *)NULL;
	
	if (pipe(fd) == -1) {
		perror("pipe");
		exit(EXIT_FAILURE);
	}
	
	cpid = fork();
	if (cpid == -1) {
		perror("fork");
		exit(EXIT_FAILURE);
	}

	if (cpid == 0) {		/* Потомок записывает в канал */
		/* Записываем в канал */
		
		close(1);	/* закроем стандартный вывод (stdout) */
		dup2(fd[1], 1);	/* отождествляем стандарный вывод (stdout) 
				  с файловым дискриптором канала, 
				  предназначенным для записи */

		close(fd[1]);	/* закрыли файловый дескриптор канала, 
				предназначенный для записи */
		
		close(fd[0]);	/* закрыли файловый дескриптор канала, 
				предназначенный для чтения */
		
		execvp(v[0], v);
		exit(0);
	} 
	else {			/* Родитель читает из канала */	
		wait(NULL);	/* Ждем окончания потомка */
		close(fd[1]);	/* закрыли файловый дескриптор канала, 
				предназначенный для записи */
		
		/* Читаем строку посимвольно, проверяя 
		 * каждый символ на равенство 0 */
		while( read(fd[0], &c, 1) > 0 ) {
			if (c == '0')
				sum_zero++;
		}

		printf("%d\n", sum_zero);
	}
	return 0;
}
